{% import 'macros.j2' as macros -%}

## Overview

**[k8s-tools.yml]({{mkdocs.site_relative_url}}/features) aggregates 20+ individual utilities for working with kubernetes into one dockerized toolchain, hosted inside a single docker-compose file.**  It's useful for CI/CD pipelines or general development, and can be [embedded alongside your existing project](/integration), which helps to fix the problem of different project developers using different local versions of things like `helm`, `kubectl`, etc.

Containers defined here aren't built from scratch, and official sources are used where possible.  Low-level tools (*like `kubectl`, `helm`, etc*) mostly come from [alpine/k8s](https://hub.docker.com/r/alpine/k8s) but [many other tools]({{mkdocs.site_relative_url}}/features) (*like `argo`, `knative`, `cdk`, `k9s`, `k3d`, `ansible`, etc*) are also included.  

However, *this isn't an attempt to build an omnibus "do-everything" container..* it's more a response to the fact that there are a lot of diverse tools that really can't be unified, so it's better to just learn how to work with that.  Tools containers are versioned independently, using defaults but allowing overrides, and are pulled only when they are used.

-------------------

Besides bundling some tooling in k8s-tools.yml, there are 2 other components that can help to build automation.Meet **`compose.mk`,** which describes core support for docker, docker-compose, and other extensions for `make`, and **`k8s.mk`,** which uses `compose.mk` to build automation APIs over the `k8s-tools.yml` containers.

**The full triple of *k8s.mk*, *compose.mk*, and *k8s-tools.yml* is called the k8s-tools suite.** 

All components of the suite can work independently to a certain extent, but they are most powerful when used together.  These tools are mostly intended to be embedded inside existing projects, not installed globally.  

You can also think of this project as a reference implementation for a pattern that [bridges compose services and Makefile targets]({{mkdocs.site_relative_url}}/compose.mk#makecompose-bridge), creating a "minimum viable automation framework" for things like [orchestrating tasks across tool containers]({{mkdocs.site_relative_url}}/compose.mk/#container-dispatch).  It's expressive and flexible, yet also focused on minimizing both conceptual overhead and software dependencies.  It's incredibly useful for lots of things, and whether it is a tool, a library, or a framework depends on how you decide to use it.  

This reference focuses on a few use-cases in particular:

1. Cluster lifecycle / development / debugging workflows in general.
1. Decoupling project automation from the choice of CI/CD backend.
1. Project-local kubernetes clusters & corresponding lifecycle automation using `kind` or `k3d`.
1. Proper separation of automation tasks from specifications for runtime / container context.
1. Less shell code in general, but where we need it: it <u>shouldn't</u> be embedded in YAML, Jenkinsfiles, etc.
1. Per-project tool-versioning, providing defaults but allowing overrides, and ensuring versions match everywhere.
1. Generally modernizing & extending `make` for containers, colors, & concurrency

There's a lot of hate for `make` (especially for "creative" usage of it!), but you'll find that these are not the Makefile's of your ancestors.  Support for [container dispatch]({{mkdocs.site_relative_url}}/compose.mk#container-dispatch) feels like a tiny, unobtrusive DSL on top of tech you already know, and you can run it anywhere you are.  Less time spent negotiating with bolted-on plugin-frameworks, hook systems, and build-bots, more time for the problems you care about.  And yes, *the build-bots themselves will be happy to run your automation,* and the output is easy to parse.  See the [this repo's github actions](https://github.com/elo-enterprises/k8s-tools/actions?query=branch%3Amaster), which bootstrap and exercise a cluster as part of the [end to end tests]({{mkdocs.site_relative_url}}/demos#demo-cluster-automation).

**Working with [compose.mk]({{mkdocs.site_relative_url}}/compose.mk) and [k8s.mk]({{mkdocs.site_relative_url}}/k8s.mk) makes `make` hit different.**  

Beyond addressing the issues above, these tools add new capabilities to `make` itself, including some support for [quickly building custom TUIs]({{mkdocs.site_relative_url}}/compose.mk#embedded-tui) from dockerized components.

{{macros.img_link("tui-6.gif", mkdocs, "90%")}}

With or without the TUI, all output is carefully curated and logged to appropriate output streams, aiming to be readable and human-friendly on stderr, while still remaining machine-friendly for downstream processing on stdout.  Help not only *works,* it also goes beyond mere target-listing to actually include namespace and per-target documentation, rendered via a dockerized version of [charmbracelete/glow](https://github.com/charmbracelet/glow).

{{macros.img_link("tui-7.gif", mkdocs, "90%")}}
